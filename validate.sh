#!/bin/bash
# Validation script for agent-teams repository
# Validates skills, agents, plugins, and commands

set -e

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

ERRORS=0
WARNINGS=0

log_error() {
    echo -e "${RED}ERROR: $1${NC}"
    ((ERRORS++)) || true
}

log_warning() {
    echo -e "${YELLOW}WARNING: $1${NC}"
    ((WARNINGS++)) || true
}

log_success() {
    echo -e "${GREEN}✓ $1${NC}"
}

log_info() {
    echo -e "  $1"
}

# Validate YAML frontmatter
validate_frontmatter() {
    local file=$1
    local content=$(cat "$file")

    # Check for frontmatter markers
    if ! echo "$content" | head -1 | grep -q "^---$"; then
        log_error "$file: Missing opening frontmatter marker (---)"
        return 1
    fi

    # Extract frontmatter
    local frontmatter=$(echo "$content" | sed -n '/^---$/,/^---$/p' | sed '1d;$d')

    # Check for name field
    if ! echo "$frontmatter" | grep -q "^name:"; then
        log_error "$file: Missing 'name' field in frontmatter"
        return 1
    fi

    # Check for description field
    if ! echo "$frontmatter" | grep -q "^description:"; then
        log_error "$file: Missing 'description' field in frontmatter"
        return 1
    fi

    # Validate name format (lowercase, hyphens only)
    local name=$(echo "$frontmatter" | grep "^name:" | sed 's/^name:[[:space:]]*//')
    if ! echo "$name" | grep -qE "^[a-z][a-z0-9-]*$"; then
        log_error "$file: Name '$name' must be lowercase with hyphens only"
        return 1
    fi

    return 0
}

# Validate skill description quality
validate_description() {
    local file=$1
    local content=$(cat "$file")
    local frontmatter=$(echo "$content" | sed -n '/^---$/,/^---$/p' | sed '1d;$d')
    local description=$(echo "$frontmatter" | grep "^description:" | sed 's/^description:[[:space:]]*//')

    # Check minimum length
    if [ ${#description} -lt 50 ]; then
        log_warning "$file: Description is short (<50 chars). Consider adding more detail."
    fi

    # Check for "Use when" pattern
    if ! echo "$description" | grep -qi "use when\|use for\|triggered when"; then
        log_warning "$file: Description should include when to use it (e.g., 'Use when...')"
    fi

    # Check for first-person language
    if echo "$description" | grep -qiE "^(I |You can|This lets you)"; then
        log_warning "$file: Description should be third-person (e.g., 'Creates...' not 'You can create...')"
    fi
}

# Validate SKILL.md line count
validate_skill_size() {
    local file=$1
    local lines=$(wc -l < "$file")

    if [ "$lines" -gt 500 ]; then
        log_warning "$file: SKILL.md has $lines lines (recommended <500). Consider using reference files."
    fi
}

# Validate agent-specific fields (model, color, example blocks)
validate_agent_fields() {
    local file=$1
    local content=$(cat "$file")
    local frontmatter=$(echo "$content" | sed -n '/^---$/,/^---$/p' | sed '1d;$d')

    # Check model field
    if echo "$frontmatter" | grep -q "^model:"; then
        local model=$(echo "$frontmatter" | grep "^model:" | sed 's/^model:[[:space:]]*//')
        if ! echo "$model" | grep -qE "^[a-zA-Z0-9_\.\/-]+$"; then
            log_error "$file: Invalid model '$model' (must be alphanumeric with hyphens, underscores, dots, or slashes)"
        fi
    else
        log_warning "$file: Missing 'model' field (defaults to inherit)"
    fi

    # Check color field
    if echo "$frontmatter" | grep -q "^color:"; then
        local color=$(echo "$frontmatter" | grep "^color:" | sed 's/^color:[[:space:]]*//')
        if ! echo "blue cyan green yellow magenta red" | grep -qw "$color"; then
            log_error "$file: Invalid color '$color' (must be blue, cyan, green, yellow, magenta, or red)"
        fi
    else
        log_warning "$file: Missing 'color' field (recommended for UI differentiation)"
    fi

    # Check for example blocks in description (best practice for reliable triggering)
    local description=$(echo "$content" | sed -n '/^---$/,/^---$/p' | sed '1d;$d' | grep "^description:")
    if ! grep -q "<example>" "$file"; then
        log_warning "$file: No <example> blocks found (recommended for reliable agent triggering)"
    fi

    # Error on YAML examples: in frontmatter (must use XML <example> blocks only)
    if echo "$frontmatter" | grep -q "^examples:"; then
        log_error "$file: YAML 'examples:' in frontmatter — must use XML <example> blocks in body instead"
    fi

    # Warn on non-canonical frontmatter field order (name → description → model → tools → color)
    local field_order=""
    while IFS= read -r line; do
        local key=$(echo "$line" | sed -n 's/^\([a-z_-]*\):.*/\1/p')
        [ -n "$key" ] && field_order="$field_order $key"
    done <<< "$frontmatter"
    local canonical=" name description model tools color"
    # Extract only canonical fields in the order they appear
    local actual_order=""
    for f in $field_order; do
        case "$f" in
            name|description|model|tools|color) actual_order="$actual_order $f" ;;
        esac
    done
    local expected_order=""
    for f in $canonical; do
        # Only include fields that actually exist
        if echo "$actual_order" | grep -qw "$f"; then
            expected_order="$expected_order $f"
        fi
    done
    if [ "$actual_order" != "$expected_order" ]; then
        log_warning "$file: Non-canonical frontmatter field order (expected:$expected_order, got:$actual_order)"
    fi
}

# Validate hooks.json schema (event names, structure, portability)
validate_hooks_schema() {
    local file=$1
    local valid_events="PreToolUse PostToolUse UserPromptSubmit Stop SubagentStop SessionStart SessionEnd PreCompact Notification"

    # Check top-level structure has "hooks" key
    if ! jq -e '.hooks' "$file" > /dev/null 2>&1; then
        log_error "$file: Missing top-level 'hooks' key"
        return 1
    fi

    # Validate event names
    local events=$(jq -r '.hooks | keys[]' "$file" 2>/dev/null)
    while IFS= read -r event; do
        [ -z "$event" ] && continue
        if ! echo "$valid_events" | grep -qw "$event"; then
            log_error "$file: Invalid event name '$event' (valid: $valid_events)"
        fi
    done <<< "$events"

    # Validate each event's hook entries
    local event_count=$(jq '.hooks | keys | length' "$file" 2>/dev/null)
    for (( i=0; i<event_count; i++ )); do
        local event_name=$(jq -r ".hooks | keys[$i]" "$file")
        local entry_count=$(jq ".hooks[\"$event_name\"] | length" "$file" 2>/dev/null)

        for (( j=0; j<entry_count; j++ )); do
            local entry_path=".hooks[\"$event_name\"][$j]"

            # Check matcher field (not required for Stop/SubagentStop events)
            if [[ "$event_name" != "Stop" ]] && [[ "$event_name" != "SubagentStop" ]]; then
                if ! jq -e "$entry_path.matcher" "$file" > /dev/null 2>&1; then
                    log_error "$file: $event_name[$j] missing 'matcher' field"
                fi
            fi

            # Check hooks array
            if ! jq -e "$entry_path.hooks" "$file" > /dev/null 2>&1; then
                log_error "$file: $event_name[$j] missing 'hooks' array"
                continue
            fi

            local hook_count=$(jq "$entry_path.hooks | length" "$file" 2>/dev/null)
            for (( k=0; k<hook_count; k++ )); do
                local hook_path="$entry_path.hooks[$k]"
                local hook_type=$(jq -r "$hook_path.type // empty" "$file")

                # Check type field
                if [ -z "$hook_type" ]; then
                    log_error "$file: $event_name[$j].hooks[$k] missing 'type' field"
                elif [ "$hook_type" != "command" ] && [ "$hook_type" != "prompt" ]; then
                    log_error "$file: $event_name[$j].hooks[$k] invalid type '$hook_type' (must be 'command' or 'prompt')"
                fi

                # Check type-specific required fields
                if [ "$hook_type" = "command" ]; then
                    if ! jq -e "$hook_path.command" "$file" > /dev/null 2>&1; then
                        log_error "$file: $event_name[$j].hooks[$k] type 'command' missing 'command' field"
                    else
                        local cmd=$(jq -r "$hook_path.command" "$file")
                        if [[ "$cmd" != *'${CLAUDE_PLUGIN_ROOT}'* ]] && [[ "$cmd" == *"/"* ]]; then
                            log_warning "$file: $event_name[$j].hooks[$k] command uses hardcoded path — consider \${CLAUDE_PLUGIN_ROOT} for portability"
                        fi
                    fi
                elif [ "$hook_type" = "prompt" ]; then
                    if ! jq -e "$hook_path.prompt" "$file" > /dev/null 2>&1; then
                        log_error "$file: $event_name[$j].hooks[$k] type 'prompt' missing 'prompt' field"
                    fi
                fi
            done
        done
    done

    return 0
}

# Validate .claude-plugin/ directory structure
validate_plugin_dir_structure() {
    local plugin_dir=$1
    local allowed_files="plugin.json marketplace.json"

    while IFS= read -r file_in_dir; do
        [ -z "$file_in_dir" ] && continue
        local basename=$(basename "$file_in_dir")
        if ! echo "$allowed_files" | grep -qw "$basename"; then
            log_warning "$plugin_dir: Unexpected file '$basename' — .claude-plugin/ should only contain plugin.json and marketplace.json"
        fi
    done < <(find "$plugin_dir" -maxdepth 1 -type f 2>/dev/null)
}

# Validate command frontmatter details (description length, allowed-tools)
validate_command_frontmatter() {
    local file=$1
    local frontmatter=$2

    # Check description length (appears in /help output, should be concise)
    if echo "$frontmatter" | grep -q "^description:"; then
        local desc=$(echo "$frontmatter" | grep "^description:" | sed 's/^description:[[:space:]]*//')
        if [ ${#desc} -gt 80 ]; then
            log_warning "$file: Command description is ${#desc} chars (recommended <=80 for /help output)"
        fi
    fi

    # Check allowed-tools format if present
    if echo "$frontmatter" | grep -q "^allowed-tools:"; then
        local tools_value=$(echo "$frontmatter" | grep "^allowed-tools:" | sed 's/^allowed-tools:[[:space:]]*//')
        # Should be a YAML list or comma-separated — warn if it looks like a single unquoted word with spaces
        if [[ "$tools_value" != "["* ]] && [[ "$tools_value" == *" "* ]] && [[ "$tools_value" != *","* ]]; then
            log_warning "$file: 'allowed-tools' format may be incorrect — use comma-separated values or YAML list"
        fi
    fi
}

# Validate plugin.json
validate_plugin_json() {
    local file=$1

    # Check JSON syntax
    if ! jq empty "$file" 2>/dev/null; then
        log_error "$file: Invalid JSON syntax"
        return 1
    fi

    # Check required fields (only 'name' is required per official docs)
    if ! jq -e '.name' "$file" > /dev/null 2>&1; then
        log_error "$file: Missing required 'name' field"
        return 1
    fi

    # Validate name format (kebab-case)
    local name=$(jq -r '.name' "$file")
    if ! echo "$name" | grep -qE "^[a-z][a-z0-9-]*$"; then
        log_error "$file: Name '$name' must be kebab-case (lowercase with hyphens)"
        return 1
    fi

    # Validate version format: X.Y.Z or X.Y.Z-dev
    local version=$(jq -r '.version // empty' "$file")
    if [ -n "$version" ]; then
        if ! echo "$version" | grep -qE "^[0-9]+\.[0-9]+\.[0-9]+(-dev)?$"; then
            log_error "$file: version '$version' must be in X.Y.Z or X.Y.Z-dev format"
            return 1
        fi
    fi

    return 0
}

# Validate marketplace.json
validate_marketplace_json() {
    local file=$1

    # Check JSON syntax
    if ! jq empty "$file" 2>/dev/null; then
        log_error "$file: Invalid JSON syntax"
        return 1
    fi

    # Check required fields
    if ! jq -e '.name' "$file" > /dev/null 2>&1; then
        log_error "$file: Missing 'name' field"
        return 1
    fi

    if ! jq -e '.plugins' "$file" > /dev/null 2>&1; then
        log_error "$file: Missing 'plugins' array"
        return 1
    fi

    # Validate plugins is an array
    if ! jq -e '.plugins | type == "array"' "$file" > /dev/null 2>&1; then
        log_error "$file: 'plugins' must be an array"
        return 1
    fi

    return 0
}

# Main validation
echo "=========================================="
echo "Agent Teams Repository Validation"
echo "=========================================="
echo ""

# Validate skills (supports nested directories: skills/*/SKILL.md and skills/*/*/SKILL.md)
echo "Validating Skills..."
skill_count=0
while IFS= read -r skill_file; do
    [ -z "$skill_file" ] && continue
    log_info "Checking $skill_file"
    validate_frontmatter "$skill_file" && log_success "Frontmatter valid"
    validate_description "$skill_file"
    validate_skill_size "$skill_file"
    ((skill_count++)) || true
done < <(find . -type f -name "SKILL.md" \( -path "./skills/*" -o -path "./plugins/*/skills/*" \) 2>/dev/null)
if [ $skill_count -eq 0 ]; then
    log_info "No skills found"
fi
echo ""

# Validate agents (agents/*/*.md - each agent in its own subdirectory)
echo "Validating Agents..."
agent_count=0
while IFS= read -r agent_file; do
    [ -z "$agent_file" ] && continue
    log_info "Checking $agent_file"
    validate_frontmatter "$agent_file" && log_success "Frontmatter valid"
    validate_description "$agent_file"
    validate_agent_fields "$agent_file"
    ((agent_count++)) || true
done < <(find . -type f -name "*.md" \( -path "./agents/*" -o -path "./plugins/*/agents/*" \) 2>/dev/null)
if [ $agent_count -eq 0 ]; then
    log_info "No agents found"
fi
echo ""

# Validate commands (commands/*.md - all frontmatter fields are optional per official docs)
echo "Validating Commands..."
cmd_count=0
while IFS= read -r cmd_file; do
    [ -z "$cmd_file" ] && continue
    log_info "Checking $cmd_file"
    local_content=$(cat "$cmd_file")

    # Check if frontmatter exists (optional but validate if present)
    if echo "$local_content" | head -1 | grep -q "^---$"; then
        cmd_frontmatter=$(echo "$local_content" | sed -n '/^---$/,/^---$/p' | sed '1d;$d')

        # Validate model field if present (can now be any valid proxy model string)
        if echo "$cmd_frontmatter" | grep -q "^model:"; then
            cmd_model=$(echo "$cmd_frontmatter" | grep "^model:" | sed 's/^model:[[:space:]]*//')
            if ! echo "$cmd_model" | grep -qE "^[a-zA-Z0-9_\.\/-]+$"; then
                log_error "$cmd_file: Invalid model '$cmd_model' (must be alphanumeric with hyphens, underscores, dots, or slashes)"
            fi
        fi

        # Validate description length and allowed-tools format
        validate_command_frontmatter "$cmd_file" "$cmd_frontmatter"

        log_success "Frontmatter valid"
    else
        log_success "No frontmatter (valid - all fields optional)"
    fi
    ((cmd_count++)) || true
done < <(find . -type f -name "*.md" \( -path "./commands/*" -o -path "./plugins/*/commands/*" \) 2>/dev/null)
if [ $cmd_count -eq 0 ]; then
    log_info "No commands found"
fi
echo ""

# Validate hooks
echo "Validating Hooks..."
hooks_found=0
for hooks_dir in hooks plugins/*/hooks; do
    [ -d "$hooks_dir" ] || continue

    if [ -f "$hooks_dir/hooks.json" ]; then
        hooks_found=1
        log_info "Checking $hooks_dir/hooks.json"
        if jq empty "$hooks_dir/hooks.json" 2>/dev/null; then
            log_success "hooks.json valid JSON"
            validate_hooks_schema "$hooks_dir/hooks.json" && log_success "hooks.json schema valid"
        else
            log_error "$hooks_dir/hooks.json: Invalid JSON syntax"
        fi

        # Check shell scripts are executable
        for hook_script in "$hooks_dir"/*.sh; do
            if [ -f "$hook_script" ]; then
                log_info "Checking $hook_script"
                if [ -x "$hook_script" ]; then
                    log_success "$hook_script is executable"
                else
                    log_error "$hook_script is not executable (run: chmod +x $hook_script)"
                fi
            fi
        done

        # Run hook integration tests if available
        if [ -f "$hooks_dir/tests/test-hooks.sh" ]; then
            log_info "Running hook integration tests..."
            if [ -x "$hooks_dir/tests/test-hooks.sh" ]; then
                if "$hooks_dir/tests/test-hooks.sh" > /tmp/hook-tests-output.txt 2>&1; then
                    log_success "Hook integration tests passed"
                else
                    log_error "Hook integration tests failed"
                    cat /tmp/hook-tests-output.txt
                fi
            else
                log_error "$hooks_dir/tests/test-hooks.sh is not executable"
            fi
        fi
    fi
done
if [ $hooks_found -eq 0 ]; then
    log_info "No hooks/hooks.json found"
fi
echo ""

# Validate feature metadata
echo "Validating Feature Metadata..."
feature_count=0
while IFS= read -r meta_file; do
    [ -z "$meta_file" ] && continue
    log_info "Checking $meta_file"

    # Validate .meta.json structure and fields
    validation_output=$(python3 -c "
import json
import sys

always_required = ['id', 'status', 'created']
deprecated = ['worktree', 'currentPhase']

try:
    with open('$meta_file') as f:
        meta = json.load(f)
except json.JSONDecodeError as e:
    print(f'ERROR: Invalid JSON: {e}')
    sys.exit(1)

errors = []
warnings = []
status = meta.get('status')

# Check always-required fields
for field in always_required:
    if field not in meta:
        errors.append(f'Missing required field: {field}')

# Status-aware required fields
if status != 'planned':
    for field in ['mode', 'branch']:
        if field not in meta or meta[field] is None:
            errors.append(f\"Missing required field: {field} (required when status != 'planned')\")
else:
    # Planned features: mode and branch should be null
    if meta.get('mode') is not None:
        warnings.append(\"Field 'mode' should be null when status is 'planned'\")
    if meta.get('branch') is not None:
        warnings.append(\"Field 'branch' should be null when status is 'planned'\")
    if meta.get('completed') is not None:
        errors.append(\"Field 'completed' must be null when status is 'planned'\")

# Check slug/name (slug is required, name is deprecated)
if 'slug' not in meta:
    if 'name' in meta:
        errors.append(\"Field 'name' must be renamed to 'slug'\")
    else:
        errors.append('Missing required field: slug')

# Check deprecated fields
for field in deprecated:
    if field in meta:
        warnings.append(f\"Deprecated field '{field}' should be removed\")

# Status consistency checks
completed = meta.get('completed')

if status == 'active' and completed is not None:
    errors.append(\"Status is 'active' but 'completed' is set\")

if status in ['completed', 'abandoned'] and completed is None:
    errors.append(f\"Status is '{status}' but 'completed' is not set\")

for e in errors:
    print(f'ERROR: {e}')
for w in warnings:
    print(f'WARNING: {w}')

sys.exit(1 if errors else 0)
" 2>&1) && python_exit=0 || python_exit=$?
    if [ $python_exit -eq 0 ]; then
        if [ -n "$validation_output" ]; then
            # Has warnings but no errors - use here-string to avoid subshell
            while IFS= read -r line; do
                [[ "$line" == WARNING:* ]] && log_warning "${line#WARNING: }"
            done <<< "$validation_output"
            log_success ".meta.json valid (with warnings)"
        else
            log_success ".meta.json valid"
        fi
    else
        # Use here-string to avoid subshell variable scope issue
        while IFS= read -r line; do
            [[ "$line" == ERROR:* ]] && log_error "$meta_file: ${line#ERROR: }"
            [[ "$line" == WARNING:* ]] && log_warning "${line#WARNING: }"
        done <<< "$validation_output"
    fi
    ((feature_count++)) || true
done < <(find docs/features -name ".meta.json" -type f 2>/dev/null)
if [ $feature_count -eq 0 ]; then
    log_info "No feature metadata found"
fi
echo ""

# Validate plugin.json files
echo "Validating Plugin Manifests..."
while IFS= read -r plugin_json; do
    [ -z "$plugin_json" ] && continue
    log_info "Checking $plugin_json"
    validate_plugin_json "$plugin_json" && log_success "plugin.json valid"
    # Check that .claude-plugin/ only contains allowed files
    validate_plugin_dir_structure "$(dirname "$plugin_json")"
done < <(find . -path "*/.claude-plugin/plugin.json" -type f 2>/dev/null)
echo ""

# Validate marketplace.json
echo "Validating Marketplace..."
while IFS= read -r marketplace_json; do
    [ -z "$marketplace_json" ] && continue
    log_info "Checking $marketplace_json"
    validate_marketplace_json "$marketplace_json" && log_success "marketplace.json valid"
done < <(find . -path "*/.claude-plugin/marketplace.json" -type f 2>/dev/null)
echo ""

# Check for stale project-level .mcp.json
echo "Checking MCP Configuration..."
if [ -f ".mcp.json" ]; then
    log_warning ".mcp.json exists at project root — MCP servers should be declared in plugin.json mcpServers instead"
fi

# Validate mcpServers script references in plugin.json files
while IFS= read -r plugin_json; do
    [ -z "$plugin_json" ] && continue
    local_plugin_dir=$(dirname "$(dirname "$plugin_json")")
    if jq -e '.mcpServers' "$plugin_json" > /dev/null 2>&1; then
        for server_name in $(jq -r '.mcpServers | keys[]' "$plugin_json" 2>/dev/null); do
            local_cmd=$(jq -r ".mcpServers[\"$server_name\"].command" "$plugin_json")
            # Replace ${CLAUDE_PLUGIN_ROOT} with the plugin's directory
            local_resolved="${local_cmd//\$\{CLAUDE_PLUGIN_ROOT\}/$local_plugin_dir}"
            if [ ! -f "$local_resolved" ]; then
                log_error "$plugin_json: mcpServers.$server_name command not found: $local_resolved"
            elif [ ! -x "$local_resolved" ]; then
                log_error "$plugin_json: mcpServers.$server_name command not executable: $local_resolved"
            else
                log_success "mcpServers.$server_name: $local_resolved exists and is executable"
            fi
        done
    fi
done < <(find . -path "*/.claude-plugin/plugin.json" -type f 2>/dev/null)
echo ""

# Validate no hardcoded plugin paths in component markdown files
echo "Checking Path Portability..."
hardcoded_path_errors=0
while IFS= read -r md_file; do
    [ -z "$md_file" ] && continue
    # Skip dev-only files, READMEs, and plans
    case "$md_file" in
        */sync-cache.md|*/README*.md|*/plan*.md) continue ;;
    esac
    # Search for hardcoded plugins/iflow/ paths with 1-line context
    # Skip lines (or preceding context lines) with fallback/conditional markers
    prev_line=""
    while IFS= read -r match_line; do
        [ -z "$match_line" ] && continue
        if [ "$match_line" = "--" ]; then
            prev_line=""
            continue
        fi
        if echo "$match_line" | grep -q 'plugins/iflow/' 2>/dev/null; then
            is_fallback=0
            for check_line in "$match_line" "$prev_line"; do
                case "$check_line" in
                    *[Ff]allback*|*"dev workspace"*|*"If "*exists*|*"if "*exists*) is_fallback=1 ;;
                esac
            done
            if [ $is_fallback -eq 0 ]; then
                log_error "$md_file: Hardcoded plugin path: $(echo "$match_line" | sed 's/^[[:space:]]*//' | head -c 120)"
                ((hardcoded_path_errors++)) || true
            fi
        fi
        prev_line="$match_line"
    done < <(grep -B1 'plugins/iflow/' "$md_file" 2>/dev/null || true)
done < <(find ./plugins/iflow/agents ./plugins/iflow/skills ./plugins/iflow/commands -name "*.md" -type f 2>/dev/null)
if [ $hardcoded_path_errors -eq 0 ]; then
    log_success "No hardcoded plugin paths in component files"
else
    log_error "Found $hardcoded_path_errors hardcoded plugin path(s) — use two-location Glob or base directory derivation instead"
fi

# Check for hardcoded artifact paths in component files
echo "Checking Artifact Path Portability..."
artifact_path_errors=0
# Patterns that should use {iflow_artifacts_root} instead of hardcoded docs/
artifact_patterns='docs/features/\|docs/brainstorms/\|docs/projects/\|docs/knowledge-bank/\|docs/backlog\|docs/rca/'
while IFS= read -r md_file; do
    [ -z "$md_file" ] && continue
    while IFS= read -r match_line; do
        [ -z "$match_line" ] && continue
        # Skip lines that already use the config variable or are in Config Variables section
        if echo "$match_line" | grep -q 'iflow_artifacts_root\|Config Variables'; then
            continue
        fi
        log_error "$md_file: Hardcoded artifact path: $(echo "$match_line" | sed 's/^[[:space:]]*//' | head -c 120)"
        ((artifact_path_errors++)) || true
    done < <(grep -n "$artifact_patterns" "$md_file" 2>/dev/null || true)
done < <(find ./plugins/iflow/skills -name "SKILL.md" -type f 2>/dev/null; find ./plugins/iflow/commands -name "*.md" -type f 2>/dev/null; find ./plugins/iflow/agents -name "*.md" -type f 2>/dev/null)
if [ $artifact_path_errors -eq 0 ]; then
    log_success "No hardcoded artifact paths in component files"
else
    log_error "Found $artifact_path_errors hardcoded artifact path(s) — use {iflow_artifacts_root} instead"
fi

# Check for hardcoded branch targets in component files
branch_target_errors=0
branch_patterns='checkout develop\|pull.*origin.*develop\|merge.*develop\|develop\.\.HEAD\|develop\.\.\.'
while IFS= read -r md_file; do
    [ -z "$md_file" ] && continue
    while IFS= read -r match_line; do
        [ -z "$match_line" ] && continue
        if echo "$match_line" | grep -q 'iflow_base_branch\|Config Variables'; then
            continue
        fi
        log_error "$md_file: Hardcoded branch target: $(echo "$match_line" | sed 's/^[[:space:]]*//' | head -c 120)"
        ((branch_target_errors++)) || true
    done < <(grep -n "$branch_patterns" "$md_file" 2>/dev/null || true)
done < <(find ./plugins/iflow/skills -name "SKILL.md" -type f 2>/dev/null; find ./plugins/iflow/commands -name "*.md" -type f 2>/dev/null)
if [ $branch_target_errors -eq 0 ]; then
    log_success "No hardcoded branch targets in component files"
else
    log_error "Found $branch_target_errors hardcoded branch target(s) — use {iflow_base_branch} instead"
fi
echo ""

# Check for @plugins/ includes in command files
at_include_errors=0
while IFS= read -r cmd_file; do
    [ -z "$cmd_file" ] && continue
    while IFS= read -r match_line; do
        [ -z "$match_line" ] && continue
        log_error "$cmd_file: @include with hardcoded path: $(echo "$match_line" | sed 's/^[[:space:]]*//' | head -c 120)"
        ((at_include_errors++)) || true
    done < <(grep -n '@plugins/' "$cmd_file" 2>/dev/null || true)
done < <(find ./plugins/iflow/commands -name "*.md" -type f 2>/dev/null)
if [ $at_include_errors -eq 0 ]; then
    log_success "No @plugins/ includes in command files"
else
    log_error "Found $at_include_errors @plugins/ include(s) — replace with inline Read via two-location Glob"
fi
echo ""

# Validate hook ERR trap usage
echo "Checking Hook ERR Traps..."
err_trap_missing=0
for hook_script in plugins/iflow/hooks/*.sh; do
    [ -f "$hook_script" ] || continue
    basename=$(basename "$hook_script")
    # Skip non-hook scripts that don't source common.sh
    case "$basename" in
        cleanup-locks.sh|cleanup-sandbox.sh) continue ;;
    esac
    # Check if it sources common.sh and has install_err_trap
    if grep -q 'source.*common\.sh' "$hook_script" 2>/dev/null; then
        if ! grep -q 'install_err_trap' "$hook_script" 2>/dev/null; then
            log_error "$hook_script: Sources common.sh but missing install_err_trap call"
            ((err_trap_missing++)) || true
        fi
    fi
done
if [ $err_trap_missing -eq 0 ]; then
    log_success "All hooks with common.sh have install_err_trap"
fi
echo ""

# Validate entry-point mkdir guards
echo "Checking Entry-Point mkdir Guards..."
mkdir_missing=0
mkdir_checks=(
    "plugins/iflow/skills/brainstorming/SKILL.md:mkdir"
    "plugins/iflow/commands/create-feature.md:mkdir"
    "plugins/iflow/commands/add-to-backlog.md:mkdir"
    "plugins/iflow/skills/root-cause-analysis/SKILL.md:mkdir"
    "plugins/iflow/skills/retrospecting/SKILL.md:mkdir"
)
for check in "${mkdir_checks[@]}"; do
    file="${check%%:*}"
    pattern="${check##*:}"
    if [ -f "$file" ]; then
        if ! grep -q "$pattern" "$file" 2>/dev/null; then
            log_error "$file: Missing $pattern guard for directory creation"
            ((mkdir_missing++)) || true
        fi
    fi
done
if [ $mkdir_missing -eq 0 ]; then
    log_success "All entry-point files have mkdir guards"
fi
echo ""


# Check for subjective adjectives in plugin component files (content-level check)
# Skips */references/* (domain-specific reference material)
# Subtracts known domain-specific compound matches
echo "Checking for Subjective Adjectives..."
ADJECTIVE_VIOLATIONS=0
ADJECTIVE_PATTERN='\b(appropriate|sufficient|robust|thorough|proper|adequate|reasonable)\b'
# Domain-specific compound exceptions (not violations)
ADJECTIVE_EXCEPTIONS='(sufficient sample|appropriate statistical test|sufficient data|robust standard error)'
ADJECTIVE_FILES=$(grep -rl --include="*.md" -E "$ADJECTIVE_PATTERN" plugins/iflow/agents plugins/iflow/skills plugins/iflow/commands 2>/dev/null | grep -v '/references/' || true)
if [ -n "$ADJECTIVE_FILES" ]; then
    while IFS= read -r file; do
        count=$(grep -cE "$ADJECTIVE_PATTERN" "$file" 2>/dev/null || true)
        exceptions=$(grep -cE "$ADJECTIVE_EXCEPTIONS" "$file" 2>/dev/null || true)
        net=$((count - exceptions))
        if [ "$net" -gt 0 ]; then
            log_error "$file: $net subjective adjective(s) found — replace with measurable criteria"
            ((ADJECTIVE_VIOLATIONS += net)) || true
        fi
    done <<< "$ADJECTIVE_FILES"
fi
if [ $ADJECTIVE_VIOLATIONS -eq 0 ]; then
    log_success "No subjective adjectives found in component files"
fi
echo ""

# Validate setup script exists
echo "Checking Setup Scripts..."
for script in plugins/iflow/scripts/doctor.sh plugins/iflow/scripts/setup.sh; do
    if [ -f "$script" ]; then
        if [ -x "$script" ]; then
            log_success "$script exists and is executable"
        else
            log_error "$script exists but is not executable"
        fi
    else
        log_warning "$script not found"
    fi
done
echo ""

# Summary
echo "=========================================="
echo "Validation Complete"
echo "=========================================="
echo "Errors: $ERRORS"
echo "Warnings: $WARNINGS"

if [ $ERRORS -gt 0 ]; then
    echo -e "${RED}Validation failed with $ERRORS error(s)${NC}"
    exit 1
else
    echo -e "${GREEN}Validation passed${NC}"
    exit 0
fi
